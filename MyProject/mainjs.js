// var Colors = {//     red:0xf25346,//     white:0xd8d0d1,//     brown:0x59332e,//     pink:0xF5986E,//     brownDark:0x23190f,//     blue:0x68c3c0,// };//// var scene,//     camera, fieldOfView, aspectRatio, nearPlane, farPlane, HEIGHT, WIDTH,//     renderer, container;//////     HEIGHT = window.innerHeight;//     WIDTH = window.innerWidth;////     // Create the scene//     scene = new THREE.Scene();////     // Add a fog effect to the scene; same color as the//     // background color used in the style sheet//     scene.fog = new THREE.Fog(0xf7d9aa, 100, 950);////     // Create the camera//     aspectRatio = WIDTH / HEIGHT;//     fieldOfView = 75;//     nearPlane = 1;//     farPlane = 10000;//     camera = new THREE.PerspectiveCamera(//         fieldOfView,//         aspectRatio,//         nearPlane,//         farPlane//     );////     //create a box//      var geometry = new THREE.BoxGeometry(1,1,1);//      //change the material here//      var material = new THREE.MeshLambertMaterial({color: 0xff3300});//      var cube = new THREE.Mesh(geometry, material); //create the cube with var geometry and material//      scene.add(cube); //add the cube into scene//      cube.castShadow = true; //you have to label shadow on things need shadow//      //add spotlight//      var spotLight = new THREE.SpotLight(0xffffff);//set a spotlight with color//      spotLight.castShadow = true;//      spotLight.position.set(15, 30, 30); //set the position//      scene.add(spotLight);//add it into scene(always do it)//      //set the camera position 数字越大图形越远（小）//      camera.position.z = 5;//////     // // Set the position of the camera//     // camera.position.x = 0;//     // camera.position.z = 200;//     // camera.position.y = 100;////     // Create the renderer//     renderer = new THREE.WebGLRenderer({////     });////     // Define the size of the renderer; in this case,//     // it will fill the entire screen//     renderer.setSize(WIDTH, HEIGHT);////     // Enable shadow rendering//     renderer.shadowMap.enabled = true;////     // Add the DOM element of the renderer to the//     // container we created in the HTML//     container = document.getElementById('container');//     container.appendChild(renderer.domElement);//    // Listen to the screen: if the user resizes it    // we have to update the camera and the renderer size////     render = function () {//     requestAnimationFrame(render);//     cube.rotation.z += 0.01;//     cube.rotation.y += 0.01;//     renderer.render(scene,camera);//     };//     render();////var scene, container;init();animate();$("#scene2").click(function() {    scene = scene2})$("#scene1").click(function() {    scene = scene1})// var btn1 = document.getElementById('scene1');// btn1.onclick = function () {//     scene = scene1;// }// var btn2 = document.getElementById('scene2');// btn2.onclick = function () {//     scene = scene2;// }function init() {    //camera    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);    camera.position.z = 5;    //renderer    var renderer = new THREE.WebGLRenderer({        // Allow transparency to show the gradient background        // we defined in the CSS        alpha: true,        // Activate the anti-aliasing; this is less performant,        // but, as our project is low-poly based, it should be fine :)        antialias: true    });    renderer.setSize(window.innerWidth, window.innerHeight);    document.body.appendChild(renderer.domElement);    var spotLight = new THREE.SpotLight(0xffffff);//set a spotlight with color    spotLight.castShadow = true;    spotLight.position.set(15, 30, 30); //set the position    scene.add(spotLight);//add it into scene(always do it)    //container    //set the magic into HTML div    container = document.getElementById('container');    container.appendChild(renderer.domElement);    // Listen to the screen: if the user resizes it    // we have to update the camera and the renderer size    window.addEventListener('resize', handleWindowResize, false);//add scene1    var scene1 = new THREE.Scene(); //set a scene    //set a camera    //add a helper here// var helper = new THREE.CameraHelper( camera );// scene.add( helper );    //add scene1    scene1 = new THREE.Scene();    var geometry = new THREE.BoxGeometry(1, 1, 1);    //change the material here    var material = new THREE.MeshLambertMaterial({color: 0xff3300});    var cube = new THREE.Mesh(geometry, material); //create the cube with var geometry and material    scene1.add(cube); //add the cube into scene    cube.castShadow = true; //you have to label shadow on things need shadow//add scene2    var scene2 = new THREE.Scene(); //set a scene    scene1.add(camera);//set a camera// var camera = new THREE.PerspectiveCamera(75, window.innerWidth/ window.innerHeight, 0.1, 1000);//add a helper here// var helper = new THREE.CameraHelper( camera );// scene.add( helper );//add scene2    scene2 = new THREE.Scene();    var geo = new THREE.BoxGeometry(2, 2, 2);//change the material here    var mat = new THREE.MeshLambertMaterial({color: 0xff8800});    var cub = new THREE.Mesh(geo, mat); //create the cube with var geometry and material    scene2.add(cub); //add the cube into scene    cub.castShadow = true; //you have to label shadow on things need shadow    scene = scene1;}// var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);     //add spotlight     // var spotLight = new THREE.SpotLight(0xffffff);//set a spotlight with color     // spotLight.castShadow = true;     // spotLight.position.set(15, 30, 30); //set the position     // scene.add(spotLight);//add it into scene(always do it)//add helper here//set the camera position// camera.position.z = 5;// var renderer = new THREE.WebGLRenderer({//     // Allow transparency to show the gradient background//     // we defined in the CSS//     alpha: true,////     // Activate the anti-aliasing; this is less performant,//     // but, as our project is low-poly based, it should be fine :)//     antialias: true// });// renderer.setSize(window.innerWidth, window.innerHeight);// document.body.appendChild(renderer.domElement);//set the animation of cube// var render = function () {//     requestAnimationFrame(render);//     cube.rotation.z += 0.01;//     cube.rotation.y += 0.01;//     cub.rotation.z += 0.01;//     cub.rotation.y += 0.01;//     renderer.render(scene,camera);// };// render();function animate() {    requestAnimationFrame(animate);    render();}function render() {    cube.rotation.z += 0.01;    cube.rotation.y += 0.01;    cub.rotation.z += 0.01;    cub.rotation.y += 0.01;    renderer.render(scene,camera);}     // var loader = new THREE.GLTFLoader();     // loader.load(     //     'abcd.gltf',     //     function (gltf) {     //         scene.add(gltf.scene);     //         gltf.animations; // Array<THREE.AnimationClip>     //         gltf.scene; // THREE.Scene     //         gltf.scenes; // Array<THREE.Scene>     //         gltf.cameras; // Array<THREE.Camera>     //         gltf.asset;     //     //     }     // )// create another scene  // //set the magic into HTML div  //    container = document.getElementById('container');  //    container.appendChild(renderer.domElement);  //  //  //  //    // Listen to the screen: if the user resizes it  //    // we have to update the camera and the renderer size  //    window.addEventListener('resize', handleWindowResize, false);     function handleWindowResize() {         // update height and width of the renderer and the camera         var HEIGHT = window.innerHeight;         var WIDTH = window.innerWidth;         renderer.setSize(WIDTH, HEIGHT);         camera.aspect = WIDTH / HEIGHT;         camera.updateProjectionMatrix();}